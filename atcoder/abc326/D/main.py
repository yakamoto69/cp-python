#!/usr/bin/env python3
import sys

YES = "Yes"  # type: str
NO = "No"  # type: str


def solve(N: int, R: str, C: str):
    R = list(map(lambda c: ord(c) - ord('A'), R))
    C = list(map(lambda c: ord(c) - ord('A'), C))
    possible_rows = []  # 横にABCができること
    for row in range(1 << (2 * N)):
        row_col = [0] * 4
        for j in range(N):
            s_col = row >> (j * 2) & 0x3
            row_col[s_col] += 1
        if row_col[0] == 1 and row_col[1] == 1 and row_col[2] == 1:
            possible_rows.append(row)

    # print(f'R={R} C={C}', file=sys.stderr)
    # print(len(possible_rows), file=sys.stderr)
    # print(possible_rows, file=sys.stderr)
    MAX = (1 << (3 * N))
    dp = [[False] * MAX for _ in range(N + 1)]
    transit_row = [[-1] * MAX for _ in range(N + 1)]
    prev_s = [[-1] * MAX for _ in range(N + 1)]
    dp[0][0] = True
    for i in range(N):
        for s in range(MAX):
            if not dp[i][s]:
                continue

            for row in possible_rows:
                ok = True
                first = True
                ns = s

                # print_cond = s == int('0b100010001', 2) and row == int('0b010010', 2)

                for j in range(N):
                    s_col = s >> (3 * j) & 0x7
                    row_col = row >> (2 * j) & 0x3
                    # 縦のABCのチェック
                    if s_col & (1 << row_col) != 0:
                        # if print_cond:
                        #     print(f'縦{j} s={bin(s)} row={bin(row)}', file=sys.stderr)
                        ok = False
                        break

                    # .以外なら
                    if row_col != 3:
                        # Rのチェック
                        if first:  # 横に初めての文字なら
                            first = False
                            if R[i] != row_col:
                                # if print_cond:
                                #     print(f'R{j} s={bin(s)} row={bin(row)} R[i]={R[i]} row_col={row_col}', file=sys.stderr)
                                ok = False
                                break

                        # Cのチェック
                        if s_col == 0:  # 縦に初めての文字なら
                            if C[j] != row_col:
                                # if print_cond:
                                #     print(f'C{j} s={bin(s)} row={bin(row)} s_col={s_col}', file=sys.stderr)
                                ok = False
                                break

                        # nsの更新
                        ns = ns | (1 << (3 * j + row_col))

                if ok:
                    # if i == 1:
                    #     print(f'OK s={bin(s)} row={bin(row)} ns={bin(ns)}', file=sys.stderr)
                    dp[i + 1][ns] = True
                    transit_row[i + 1][ns] = row
                    prev_s[i + 1][ns] = s

    # print(f'dp[1]={dp[1]}', file=sys.stderr)

    chars = "ABC."
    cur = MAX - 1
    if dp[N][cur]:
        print(YES)
        ans = []
        for i in range(N, 0, -1):
            row = transit_row[i][cur]
            # print(f'cur={bin(cur)} row={bin(row)}', file=sys.stderr)
            str = "".join([chars[row >> (2 * j) & 0x3] for j in range(N)])
            ans.append(str)
            cur = prev_s[i][cur]
        # print(f'ans={ans}', file=sys.stderr)
        ans.reverse()
        for str in ans:
            print(str)

    else:
        print(NO)


# Generated by 2.14.0 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    R = next(tokens)  # type: str
    C = next(tokens)  # type: str
    solve(N, R, C)

if __name__ == '__main__':
    main()
