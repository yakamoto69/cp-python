#!/usr/bin/env python3
import sys
from collections import deque
from typing import List

YES = "Yes"  # type: str
NO = "No"  # type: str


# 隣接リスト形式で(node_id, edge_id)が入っている
def pack_undirected_graph(N: int, M: int, s: List[int], t: List[int]) -> "List[List[(int, int)]]":
    p = [0] * N
    for e in range(M):
        p[s[e]] += 1
        p[t[e]] += 1
    g = [[(-1, -1)] * p[i] for i in range(N)]
    for e in range(M):
        u = s[e]
        v = t[e]
        p[u] -= 1
        p[v] -= 1
        g[u][p[u]] = (v, e)
        g[v][p[v]] = (u, e)
    return g


def solve(N: int, M: int, v: "List[int]", u: "List[int]", K: int, p: "List[int]", d: "List[int]"):
    # 条件が１個もないので１つだけ黒にして終わる
    if K == 0:
        ans = [0] * N
        ans[0] = 1
        print(YES)
        print("".join(map(str, ans)))
        return

    for i in range(M):
        v[i] -= 1
        u[i] -= 1

    for i in range(K):
        p[i] -= 1

    g = pack_undirected_graph(N, M, v, u)
    inf = int(1e9)
    mat = [[inf] * N for _ in range(N)]
    que = deque()
    for s in range(N):
        que.append(s)
        mat[s][s] = 0
        while que:
            u = que.popleft()
            for v, e in g[u]:
                if mat[s][v] > mat[s][u] + 1:
                    mat[s][v] = mat[s][u] + 1
                    que.append(v)

    ok = [True] * N
    for k in range(K):
        u = p[k]
        dist = d[k]
        for v in range(N):
            if mat[u][v] < dist:
                ok[v] = False

    ans = [0] * N
    for k in range(K):
        u = p[k]
        dist = d[k]
        found = False
        for v in range(N):
            if mat[u][v] == dist and ok[v]:
                ans[v] = 1
                found = True
                break
        if not found:
            print(NO)
            return

    print(YES)
    print("".join(map(str, ans)))

    return


# Generated by 2.12.0 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    M = int(next(tokens))  # type: int
    u = [int()] * (M)  # type: "List[int]"
    v = [int()] * (M)  # type: "List[int]"
    for i in range(M):
        u[i] = int(next(tokens))
        v[i] = int(next(tokens))
    K = int(next(tokens))  # type: int
    p = [int()] * (K)  # type: "List[int]"
    d = [int()] * (K)  # type: "List[int]"
    for i in range(K):
        p[i] = int(next(tokens))
        d[i] = int(next(tokens))
    solve(N, M, u, v, K, p, d)


if __name__ == '__main__':
    main()
