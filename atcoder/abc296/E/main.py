#!/usr/bin/env python3
import sys
from typing import List


def find_cycle_in_functional_graph(N: int, to: List[int]) -> List[List[int]]:
    flg = [0] * N

    ans: List[List[int]] = []
    path = []

    def dfs(u: int):
        path.append(u)
        while path:
            u = path.pop()
            if flg[u] == 0:
                flg[u] = 1
                path.append(u)
                v = to[u]
                if flg[v] == 0:
                    path.append(v)
                elif flg[v] == 1:
                    idx = path.index(v)
                    ans.append(path[idx:])
                    # dfsしているので、ここでbreakすると戻りの処理がされなくなってしまう
            elif flg[u] == 1:
                flg[u] = 2
            else:
                raise f"flg[u] is invalid u:{u} flg[u]:{flg[u]}"

    for u in range(N):
        if flg[u] == 0:
            dfs(u)
    return ans


def solve(N: int, A: "List[int]"):
    for i in range(len(A)):
        A[i] -= 1
    cycles = find_cycle_in_functional_graph(N, A)
    # print(cycles, file=sys.stderr)
    ans = sum([len(c) for c in cycles])
    print(ans)
    return


# Generated by 2.12.0 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    A = [int(next(tokens)) for _ in range(N)]  # type: "List[int]"
    solve(N, A)

if __name__ == '__main__':
    main()
