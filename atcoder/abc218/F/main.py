#!/usr/bin/env python3
import sys
from collections import deque
from typing import List


def pack_direct_graph(N: int, M: int, s: List[int], t: List[int]) -> "List[List[(int, int)]]":
    p = [0] * N
    for e in range(M):
        p[s[e]] += 1
    g = [[(-1, -1)] * p[i] for i in range(N)]
    for e in range(M):
        u = s[e]
        v = t[e]
        p[u] -= 1
        g[u][p[u]] = (v, e)
    return g

def solve(N: int, M: int, s: "List[int]", t: "List[int]"):
    for e in range(M):
        s[e] -= 1
        t[e] -= 1
    g = pack_direct_graph(N, M, s, t)

    inf = int(1e9)

    def dijkstra(blocked: int):
        que = deque()
        que.append(0)
        D = [inf] * N
        D[0] = 0
        route = [(N, M)] * N  # (node, edge)
        while que:
            u = que.pop()
            for v, e in g[u]:
                if e == blocked:
                    continue

                if D[v] > D[u] + 1:
                    D[v] = D[u] + 1
                    route[v] = (u, e)
                    que.append(v)
        return D, route

    D, route = dijkstra(N)
    min_route_edges = [False] * M
    if route[N - 1][0] < N:
        v = N - 1
        while v != 0:
            min_route_edges[route[v][1]] = True
            v = route[v][0]

    def solve_except(e: int) -> int:
        D, route = dijkstra(e)
        # print(D, file=sys.stderr)
        return D[N - 1]

    ans = [-1] * M
    for e in range(M):
        if min_route_edges[e]:
            d = solve_except(e)
        else:
            d = D[N - 1]
        ans[e] = -1 if d == inf else d

    print(*ans, sep='\n')

    return


# Generated by 2.12.0 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    M = int(next(tokens))  # type: int
    s = [int()] * (M)  # type: "List[int]"
    t = [int()] * (M)  # type: "List[int]"
    for i in range(M):
        s[i] = int(next(tokens))
        t[i] = int(next(tokens))
    solve(N, M, s, t)

if __name__ == '__main__':
    main()
