import types

#!/usr/bin/env python3
import sys
from collections import deque
from typing import List


# Generated by 2.12.0 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    H, W, T = map(int, input().split())
    g = [input() for _ in range(H)]
    pos = []
    for i in range(H):
        for j in range(W):
            if g[i][j] == 'o':
                n_key = W * i + j
                pos.append(n_key)

    N0 = len(pos)
    N = N0 + 2
    S = N0
    G = N0 + 1
    pos.append(-1)  # S
    pos.append(-1)  # G

    for u in range(H):
        for j in range(W):
            if g[u][j] == 'S':
                n_key = W * u + j
                pos[S] = n_key

            if g[u][j] == 'G':
                n_key = W * u + j
                pos[G] = n_key

    # print(f"S:{S} G:{G} pos:{pos}", file=sys.stderr)

    dir = [(1, 0), (-1, 0), (0, 1), (0, -1)]

    def dijkstra(s: int) -> List[int]:
        inf = int(1e9)
        que = deque()
        que.append(s)
        D = [inf] * (H * W)
        D[s] = 0
        while len(que):
            u = que.popleft()
            i = u // W
            j = u % W
            # print(f"u:{u} i:{i} j:{j}", file=sys.stderr)
            for d in dir:
                ni = i + d[0]
                nj = j + d[1]
                # print(f"ni:{ni} nj:{nj}", file=sys.stderr)
                if 0 <= ni < H and 0 <= nj < W and g[ni][nj] != '#':
                    v = ni * W + nj
                    if D[v] > D[u] + 1:
                        D[v] = D[u] + 1
                        que.append(v)
        # print(f"dijkstra({s}) = {D}", file=sys.stderr)
        return D

    def calcDist(u: int):
        D = dijkstra(pos[u])
        # print(f"calcDist({u}) D:{D}", file=sys.stderr)
        return [D[pos[v]] for v in range(N)]

    dist = [calcDist(u) for u in range(N)]
    # print(f"dist:{dist}", file=sys.stderr)
    MAX = (1 << N)
    dp = [T] * (MAX * N)
    dp[(1 << S) + MAX * S] = 0

    for mask in range(1 << N0):  #○だけ
        for u in range(N0 + 1):   # Sを含める
            mask1 = mask | (1 << S)  # Sはon, Gはoffになる
            if mask1 >> u & 1 == 0:
                continue
            i = mask1 + MAX * u

            for v in range(N0):  # ○だけ
                # print(f"u:{u} v:{v}", file=sys.stderr)
                if mask1 >> v & 1 == 1:
                    continue
                if dp[i] + dist[u][v] > T:
                    continue
                ni = (mask1 | (1 << v)) + MAX * v
                dp[ni] = min(dp[ni], dp[i] + dist[u][v])

    # print(f"dp:{dp}", file=sys.stderr)

    ans = -1
    for mask in range(1 << (N0 + 1)):  # Sを含める
        for u in range(N0 + 1):   # Sを含める
            if mask >> u & 1 == 0:
                continue
            i = mask + MAX * u
            if dp[i] + dist[u][G] <= T:
                ans = max(ans, bin(mask).count("1") - 1)  # Sを除く

    print(ans)

    return


if __name__ == '__main__':
    main()
