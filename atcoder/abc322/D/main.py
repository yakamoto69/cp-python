#!/usr/bin/env python3
import typing
import sys

YES = "Yes"  # type: str
NO = "No"  # type: str


def moves(P: list[list[bool]]):
    has_any = False
    for i in range(4):
        has_any = has_any or any(P[i])
    if not has_any:
        yield 0, 0, 0
        return

    min_i, max_i, min_j, max_j = 3, 0, 3, 0
    for i in range(4):
        for j in range(4):
            if P[i][j]:
                min_i = min(i, min_i)
                max_i = max(i, max_i)
                min_j = min(j, min_j)
                max_j = max(j, max_j)

    for i in range(-min_i, (3 - max_i) + 1):
        for j in range(-min_j, (3 - max_j) + 1):
            for d in range(4):
                yield d, i, j


def apply(d, di, dj, P, grid):
    for i in range(4):
        for j in range(4):
            if not P[i][j]:
                continue

            i1 = i + di
            j1 = j + dj

            ni, nj = -1, -1
            if d == 0:
                ni, nj = i1, j1
            elif d == 1:
                ni, nj = j1, 3 - i1
            elif d == 2:
                ni, nj = 3 - i1, 3 - j1
            elif d == 3:
                ni, nj = 3 - j1, i1

            if grid[ni][nj]:
                # print(f'collide {d} {di} {dj}', file=sys.stderr)
                return False

            grid[ni][nj] = True

    return True


def is_filled(grid):
    res = True
    for i in range(4):
        res = res and all(grid[i])
    return res


# Generated by 2.14.0 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    P = [[list(map(lambda x: x == '#', input())) for _ in range(4)] for _ in range(3)]

    # for d0, i0, j0 in moves(P[0]):
    #     print(f'd0={d0} i0={i0} j0={j0}', file=sys.stderr)

    grid = [[False] * 4 for _ in range(4)]
    for d0, i0, j0 in moves(P[0]):
        # print(f'd0={d0} i0={i0} j0={j0}', file=sys.stderr)
        for d1, i1, j1 in moves(P[1]):
            # print(f'd1={d1} i1={i1} j1={j1}', file=sys.stderr)
            for d2, i2, j2 in moves(P[2]):
                # print(f'd2={d2} i2={i2} j2={j2}', file=sys.stderr)

                # gridの初期化
                for i in range(4):
                    for j in range(4):
                        grid[i][j] = False

                not_collide = (apply(d0, i0, j0, P[0], grid) and
                               apply(d1, i1, j1, P[1], grid) and
                               apply(d2, i2, j2, P[2], grid))

                if not_collide and is_filled(grid):
                    print(YES)
                    return

    print(NO)


if __name__ == '__main__':
    main()
