import types

_atcoder_code = """
# Python port of AtCoder Library.

__version__ = '0.0.1'
"""

atcoder = types.ModuleType('atcoder')
exec(_atcoder_code, atcoder.__dict__)

_atcoder_dsu_code = """
import typing


class DSU:
    '''
    Implement (union by size) + (path halving)

    Reference:
    Zvi Galil and Giuseppe F. Italiano,
    Data structures and algorithms for disjoint set union problems
    '''

    def __init__(self, n: int = 0) -> None:
        self._n = n
        self.parent_or_size = [-1] * n

    def merge(self, a: int, b: int) -> int:
        assert 0 <= a < self._n
        assert 0 <= b < self._n

        x = self.leader(a)
        y = self.leader(b)

        if x == y:
            return x

        if -self.parent_or_size[x] < -self.parent_or_size[y]:
            x, y = y, x

        self.parent_or_size[x] += self.parent_or_size[y]
        self.parent_or_size[y] = x

        return x

    def same(self, a: int, b: int) -> bool:
        assert 0 <= a < self._n
        assert 0 <= b < self._n

        return self.leader(a) == self.leader(b)

    def leader(self, a: int) -> int:
        assert 0 <= a < self._n

        parent = self.parent_or_size[a]
        while parent >= 0:
            if self.parent_or_size[parent] < 0:
                return parent
            self.parent_or_size[a], a, parent = (
                self.parent_or_size[parent],
                self.parent_or_size[parent],
                self.parent_or_size[self.parent_or_size[parent]]
            )

        return a

    def size(self, a: int) -> int:
        assert 0 <= a < self._n

        return -self.parent_or_size[self.leader(a)]

    def groups(self) -> typing.List[typing.List[int]]:
        leader_buf = [self.leader(i) for i in range(self._n)]

        result: typing.List[typing.List[int]] = [[] for _ in range(self._n)]
        for i in range(self._n):
            result[leader_buf[i]].append(i)

        return list(filter(lambda r: r, result))
"""

atcoder.dsu = types.ModuleType('atcoder.dsu')
exec(_atcoder_dsu_code, atcoder.dsu.__dict__)
DSU = atcoder.dsu.DSU

#!/usr/bin/env python3
import sys
from typing import List

# from atcoder.dsu import DSU


# Undirected Graph用。隣接リスト形式で(node_id, weignt)が入っている
def pack_undirected_graph(N: int, edges: List[int], s: List[int], t: List[int], w: List[int]) -> "List[List[(int, int)]]":
    p = [0] * N
    for e in edges:
        p[s[e]] += 1
        p[t[e]] += 1
    g = [[(-1, -1)] * p[i] for i in range(N)]
    for e in edges:
        u = s[e]
        v = t[e]
        p[u] -= 1
        p[v] -= 1
        g[u][p[u]] = (v, w[e])
        g[v][p[v]] = (u, -w[e])
    return g


def solve(N: int, M: int, Q: int, A: "List[int]", B: "List[int]", C: "List[int]", X: "List[int]", Y: "List[int]"):
    for i in range(M):
        A[i] -= 1
        B[i] -= 1

    for i in range(Q):
        X[i] -= 1
        Y[i] -= 1

    dsu = DSU(N)
    tree_edges = []
    used_as_tree_edge = [False] * M
    for i in range(M):
        v, u = A[i], B[i]
        if not dsu.same(v, u):
            dsu.merge(v, u)
            tree_edges.append(i)
            used_as_tree_edge[i] = True


    # print(f"tree_edges={tree_edges}", file=sys.stderr)

    g = pack_undirected_graph(N, tree_edges, A, B, C)

    # print(f"g={g}", file=sys.stderr)

    visited = [False] * N
    que = []
    gain = [-int(1e18)] * N
    par = [N] * N
    for i in range(N):
        if not visited[i]:
            rt = dsu.leader(i)
            que.append(rt)
            gain[rt] = 0
            while que:
                u = que.pop()
                # print(f"u={u}", file=sys.stderr)
                visited[u] = True
                for e in g[u]:
                    v, w = e
                    if par[u] == v:
                        continue
                    que.append(v)
                    gain[v] = gain[u] + w
                    par[v] = u

    # print(f"gain={gain}", file=sys.stderr)

    is_inf = [False] * N
    for i in range(M):
        if not used_as_tree_edge[i]:
            rt = dsu.leader(A[i])
            if not is_inf[rt]:
                gain_u = gain[A[i]]
                gain_v = gain[B[i]]
                w = C[i]
                if gain_v - gain_u != w:
                    is_inf[rt] = True

    # print(f"is_inf={is_inf}", file=sys.stderr)

    for i in range(Q):
        u, v = X[i], Y[i]
        ans = "nan"
        if dsu.same(u, v):
            if is_inf[dsu.leader(u)]:
                ans = "inf"
            else:
                ans = gain[v] - gain[u]
        print(ans)

    return


# Generated by 2.12.0 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    M = int(next(tokens))  # type: int
    Q = int(next(tokens))  # type: int
    A = [int()] * (M)  # type: "List[int]"
    B = [int()] * (M)  # type: "List[int]"
    C = [int()] * (M)  # type: "List[int]"
    for i in range(M):
        A[i] = int(next(tokens))
        B[i] = int(next(tokens))
        C[i] = int(next(tokens))
    X = [int()] * (Q)  # type: "List[int]"
    Y = [int()] * (Q)  # type: "List[int]"
    for i in range(Q):
        X[i] = int(next(tokens))
        Y[i] = int(next(tokens))
    solve(N, M, Q, A, B, C, X, Y)

if __name__ == '__main__':
    main()
