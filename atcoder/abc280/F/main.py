#!/usr/bin/env python3
import sys
from typing import List

from atcoder.dsu import DSU


# Undirected Graph用。隣接リスト形式で(node_id, weignt)が入っている
def pack_undirected_graph(N: int, edges: List[int], s: List[int], t: List[int], w: List[int]) -> "List[List[(int, int)]]":
    p = [0] * N
    for e in edges:
        p[s[e]] += 1
        p[t[e]] += 1
    g = [[(-1, -1)] * p[i] for i in range(N)]
    for e in edges:
        u = s[e]
        v = t[e]
        p[u] -= 1
        p[v] -= 1
        g[u][p[u]] = (v, w[e])
        g[v][p[v]] = (u, -w[e])
    return g


def solve(N: int, M: int, Q: int, A: "List[int]", B: "List[int]", C: "List[int]", X: "List[int]", Y: "List[int]"):
    for i in range(M):
        A[i] -= 1
        B[i] -= 1

    for i in range(Q):
        X[i] -= 1
        Y[i] -= 1

    dsu = DSU(N)
    tree_edges = []
    used_as_tree_edge = [False] * M
    for i in range(M):
        v, u = A[i], B[i]
        if not dsu.same(v, u):
            dsu.merge(v, u)
            tree_edges.append(i)
            used_as_tree_edge[i] = True


    # print(f"tree_edges={tree_edges}", file=sys.stderr)

    g = pack_undirected_graph(N, tree_edges, A, B, C)

    # print(f"g={g}", file=sys.stderr)

    visited = [False] * N
    que = []
    gain = [-int(1e18)] * N
    par = [N] * N
    for i in range(N):
        if not visited[i]:
            rt = dsu.leader(i)
            que.append(rt)
            gain[rt] = 0
            while que:
                u = que.pop()
                # print(f"u={u}", file=sys.stderr)
                visited[u] = True
                for e in g[u]:
                    v, w = e
                    if par[u] == v:
                        continue
                    que.append(v)
                    gain[v] = gain[u] + w
                    par[v] = u

    # print(f"gain={gain}", file=sys.stderr)

    is_inf = [False] * N
    for i in range(M):
        if not used_as_tree_edge[i]:
            rt = dsu.leader(A[i])
            if not is_inf[rt]:
                gain_u = gain[A[i]]
                gain_v = gain[B[i]]
                w = C[i]
                if gain_v - gain_u != w:
                    is_inf[rt] = True

    # print(f"is_inf={is_inf}", file=sys.stderr)

    for i in range(Q):
        u, v = X[i], Y[i]
        ans = "nan"
        if dsu.same(u, v):
            if is_inf[dsu.leader(u)]:
                ans = "inf"
            else:
                ans = gain[v] - gain[u]
        print(ans)

    return


# Generated by 2.12.0 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    M = int(next(tokens))  # type: int
    Q = int(next(tokens))  # type: int
    A = [int()] * (M)  # type: "List[int]"
    B = [int()] * (M)  # type: "List[int]"
    C = [int()] * (M)  # type: "List[int]"
    for i in range(M):
        A[i] = int(next(tokens))
        B[i] = int(next(tokens))
        C[i] = int(next(tokens))
    X = [int()] * (Q)  # type: "List[int]"
    Y = [int()] * (Q)  # type: "List[int]"
    for i in range(Q):
        X[i] = int(next(tokens))
        Y[i] = int(next(tokens))
    solve(N, M, Q, A, B, C, X, Y)

if __name__ == '__main__':
    main()
